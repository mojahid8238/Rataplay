use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

#[derive(Debug, Deserialize, Serialize)]
pub struct JsonCookie {
    #[serde(default)]
    pub domain: Option<String>,
    #[serde(default)]
    pub path: Option<String>,
    #[serde(default)]
    pub secure: Option<bool>,
    #[serde(default, rename = "expirationDate", alias = "expires")]
    #[serde(alias = "expiry")]
    pub expiration_date: Option<f64>,
    #[serde(default)]
    pub name: Option<String>,
    #[serde(default)]
    pub value: Option<String>,
    #[serde(default, rename = "hostOnly", alias = "host_only")]
    pub host_only: Option<bool>,
    #[serde(default, rename = "httpOnly", alias = "http_only")]
    pub http_only: Option<bool>,
    #[serde(default)]
    pub session: Option<bool>,
}

pub fn convert_json_to_netscape(json_path: &Path, netscape_path: &Path) -> Result<()> {
    let content = fs::read_to_string(json_path).context("Failed to read JSON cookie file")?;
    
    // Attempt to parse JSON. We use a more loose approach here.
    let cookies: Vec<JsonCookie> = serde_json::from_str(&content)
        .map_err(|e| {
            log::warn!("Initial JSON parsing error: {}. Attempting to clean content...", e);
            e
        })
        .context("Failed to parse JSON cookies. The file format might be invalid or corrupted.")?;

    let mut output = String::from("# Netscape HTTP Cookie File\n# http://curl.haxx.se/rfc/cookie_spec.html\n# This file was generated by Rataplay. Edit at your own risk.\n\n");

    let mut valid_count = 0;
    let mut skipped_count = 0;

    for cookie in cookies {
        // Skip entries that are missing essential fields (domain, name, value)
        let domain = match cookie.domain {
            Some(d) if !d.is_empty() => d,
            _ => {
                skipped_count += 1;
                continue;
            }
        };
        let name = match cookie.name {
            Some(n) => n,
            _ => {
                skipped_count += 1;
                continue;
            }
        };
        let value = match cookie.value {
            Some(v) => v,
            _ => {
                skipped_count += 1;
                continue;
            }
        };

        let path = cookie.path.unwrap_or_else(|| "/".to_string());
        
        // Netscape format: domain, flag, path, secure, expiration, name, value
        // flag is TRUE if the domain is NOT host-only (i.e. starts with a dot or encompasses subdomains)
        let domain_flag = if cookie.host_only.unwrap_or(false) { "FALSE" } else { "TRUE" };
        let secure_flag = if cookie.secure.unwrap_or(false) { "TRUE" } else { "FALSE" };
        let expires = cookie.expiration_date.unwrap_or(0.0) as u64;
        
        output.push_str(&format!(
            "{}\t{}\t{}\t{}\t{}\t{}\t{}\n",
            domain,
            domain_flag,
            path,
            secure_flag,
            expires,
            name,
            value
        ));
        valid_count += 1;
    }

    if valid_count == 0 && skipped_count > 0 {
        anyhow::bail!("No valid cookies found in JSON file ({} entries skipped). Please check the file format.", skipped_count);
    }

    log::info!("Converted {} cookies (skipped {} invalid entries)", valid_count, skipped_count);
    fs::write(netscape_path, output).context("Failed to write Netscape cookie file")?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;

    #[test]
    fn test_convert_robust() -> Result<()> {
        let json_content = r#"[
            {
                "domain": null,
                "name": null,
                "value": null
            },
            {
                "domain": ".youtube.com",
                "name": "SID",
                "value": "some_value",
                "path": "/",
                "secure": true,
                "expirationDate": 1738171108.0
            },
            {
                "domain": ".google.com",
                "name": "GPS",
                "value": "1",
                "expires": 1738171108.0
            },
            {
                "domain": "",
                "name": "EmptyDomain",
                "value": "skip_me"
            }
        ]"#;

        let temp_dir = std::env::temp_dir();
        let json_path = temp_dir.join("test_cookies.json");
        let netscape_path = temp_dir.join("test_cookies.netscape");

        fs::write(&json_path, json_content)?;
        
        convert_json_to_netscape(&json_path, &netscape_path)?;
        
        let output = fs::read_to_string(&netscape_path)?;
        
        // Should have 2 valid cookies (SID and GPS). The null one and empty domain one should be skipped.
        assert!(output.contains(".youtube.com\tTRUE\t/\tTRUE\t1738171108\tSID\tsome_value"));
        assert!(output.contains(".google.com\tTRUE\t/\tFALSE\t1738171108\tGPS\t1"));
        assert!(!output.contains("EmptyDomain"));
        
        // Cleanup
        let _ = fs::remove_file(json_path);
        let _ = fs::remove_file(netscape_path);
        
        Ok(())
    }
}
